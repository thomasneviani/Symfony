# APPROCHE 1 : LEGACY ROUTE LOADER

## Phase 0 : Configuration initiale

### Structure de dossiers
```
project/
├── legacy/
│   ├── login.php
│   ├── dashboard.php
│   └── templates/
├── public/
│   └── index.php
├── src/
│   ├── Infrastructure/
│   │   ├── Routing/
│   │   │   └── LegacyRouteLoader.php
│   │   └── Controller/
│   │       └── LegacyController.php
│   ├── Domain/
│   ├── Application/
│   └── Presentation/
└── config/
```

### 1. Custom Route Loader

```php
<?php
// src/Infrastructure/Routing/LegacyRouteLoader.php
namespace App\Infrastructure\Routing;

use Symfony\Component\Config\Loader\Loader;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;

class LegacyRouteLoader extends Loader
{
    private bool $isLoaded = false;
    
    public function __construct(
        private readonly string $legacyPath
    ) {}
    
    public function load(mixed $resource, ?string $type = null): RouteCollection
    {
        if ($this->isLoaded) {
            throw new \RuntimeException('Do not add the "legacy" loader twice');
        }
        
        $routes = new RouteCollection();
        
        // Route catch-all pour tout le legacy
        $catchAll = new Route('/{path}', [
            '_controller' => 'App\Infrastructure\Controller\LegacyController::handleLegacy',
        ], [
            'path' => '.+',
        ]);
        $routes->add('legacy_catch_all', $catchAll);
        
        $this->isLoaded = true;
        return $routes;
    }
    
    public function supports(mixed $resource, ?string $type = null): bool
    {
        return 'legacy' === $type;
    }
}
```

### 2. Legacy Controller

```php
<?php
// src/Infrastructure/Controller/LegacyController.php
namespace App\Infrastructure\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\DependencyInjection\ContainerInterface;

class LegacyController extends AbstractController
{
    public function __construct(
        private readonly string $legacyPath,
        private readonly array $legacyGlobals = []
    ) {}
    
    public function handleLegacy(Request $request): Response
    {
        $path = $request->getPathInfo();
        $scriptPath = $this->legacyPath . $path;
        
        // Ajouter .php si nécessaire
        if (!file_exists($scriptPath) && !str_ends_with($scriptPath, '.php')) {
            $scriptPath .= '.php';
        }
        
        if (!file_exists($scriptPath)) {
            throw $this->createNotFoundException('Legacy script not found');
        }
        
        return $this->executeLegacyScript($request, $scriptPath);
    }
    
    private function executeLegacyScript(Request $request, string $scriptPath): Response
    {
        // Initialiser variables globales
        foreach ($this->legacyGlobals as $name => $value) {
            $GLOBALS[$name] = $value;
        }
        
        // Synchroniser superglobales
        $_GET = $request->query->all();
        $_POST = $request->request->all();
        $_SERVER['REQUEST_METHOD'] = $request->getMethod();
        $_SERVER['REQUEST_URI'] = $request->getRequestUri();
        $_SERVER['PHP_SELF'] = $request->getPathInfo();
        
        // Session gérée automatiquement par Symfony
        $session = $request->getSession();
        
        // Capturer la sortie
        ob_start();
        
        try {
            // Le container Symfony est accessible dans le script
            $container = $this->container;
            
            // Changer répertoire de travail
            $originalDir = getcwd();
            chdir(dirname($scriptPath));
            
            require $scriptPath;
            
            chdir($originalDir);
            
            $content = ob_get_clean();
            
            // Gérer les redirections
            $headers = headers_list();
            $response = new Response($content);
            
            foreach ($headers as $header) {
                if (stripos($header, 'Location:') === 0) {
                    $location = trim(substr($header, 9));
                    if (!headers_sent()) {
                        header_remove();
                    }
                    return $this->redirect($location);
                }
            }
            
            if (!headers_sent()) {
                header_remove();
            }
            
            return $response;
            
        } catch (\Throwable $e) {
            ob_end_clean();
            throw $e;
        }
    }
}
```

### 3. Configuration

```yaml
# config/services.yaml
services:
    _defaults:
        autowire: true
        autoconfigure: true
    
    App\:
        resource: '../src/'
        exclude:
            - '../src/Domain/*/Entity/'
            - '../src/Domain/*/ValueObject/'
    
    App\Infrastructure\Routing\LegacyRouteLoader:
        arguments:
            $legacyPath: '%kernel.project_dir%/legacy'
        tags:
            - { name: routing.loader }
    
    App\Infrastructure\Controller\LegacyController:
        arguments:
            $legacyPath: '%kernel.project_dir%/legacy'
            $legacyGlobals:
                ERP_API_URL: '%env(ERP_API_URL)%'
        public: true
```

```yaml
# config/routes.yaml
# Routes Symfony (haute priorité)
app_routes:
    resource: ../src/Presentation/Controller/
    type: attribute
    priority: 100

# Routes legacy (basse priorité)
legacy:
    resource: .
    type: legacy
    priority: -100
```

```yaml
# config/packages/framework.yaml
framework:
    session:
        handler_id: null  # Utilise le handler PHP natif
        name: PHPSESSID
        cookie_lifetime: 3600
        cookie_secure: auto
        cookie_samesite: lax
```

### 4. Script legacy initial (fonctionne sans modification)

```php
<?php
// legacy/login.php - PHASE 0 : Fonctionne tel quel
// session_start(); ← Pas besoin, géré par Symfony

global $ERP_API_URL;

$error = '';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'] ?? '';
    $password = $_POST['password'] ?? '';
    
    if (empty($username) || empty($password)) {
        $error = 'Username et password requis';
    } else {
        $ch = curl_init($ERP_API_URL . '/auth');
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode([
            'username' => $username,
            'password' => $password
        ]));
        curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        
        if ($httpCode === 200) {
            $data = json_decode($response, true);
            $_SESSION['token'] = $data['token'];
            $_SESSION['user_id'] = $data['user_id'];
            $_SESSION['username'] = $username;
            
            header('Location: /dashboard.php');
            exit;
        } else {
            $error = 'Identifiants invalides';
        }
    }
}
?>
<!DOCTYPE html>
<html>
<head>
    <title>Login Legacy</title>
</head>
<body>
    <h1>Connexion</h1>
    
    <?php if ($error): ?>
        <div style="color: red;"><?= htmlspecialchars($error) ?></div>
    <?php endif; ?>
    
    <form method="POST" action="/login.php">
        <div>
            <label>Username:</label>
            <input type="text" name="username" required>
        </div>
        
        <div>
            <label>Password:</label>
            <input type="password" name="password" required>
        </div>
        
        <button type="submit">Se connecter</button>
    </form>
</body>
</html>
```

***

## Phase 1 : Extraction du service HTTP

### 1. Créer le service d'authentification

```php
<?php
// src/Infrastructure/Legacy/Service/LegacyAuthenticationService.php
namespace App\Infrastructure\Legacy\Service;

use Symfony\Contracts\HttpClient\HttpClientInterface;

class LegacyAuthenticationService
{
    public function __construct(
        private readonly HttpClientInterface $httpClient,
        private readonly string $erpApiUrl
    ) {}
    
    public function authenticate(string $username, string $password): ?array
    {
        try {
            $response = $this->httpClient->request('POST', $this->erpApiUrl . '/auth', [
                'json' => [
                    'username' => $username,
                    'password' => $password
                ],
                'timeout' => 10
            ]);
            
            if ($response->getStatusCode() === 200) {
                return $response->toArray();
            }
            
            return null;
        } catch (\Exception $e) {
            // Logger l'erreur si nécessaire
            return null;
        }
    }
}
```

### 2. Configuration du service

```yaml
# config/services.yaml (ajout)
services:
    App\Infrastructure\Legacy\Service\LegacyAuthenticationService:
        arguments:
            $erpApiUrl: '%env(ERP_API_URL)%'
        public: true  # IMPORTANT pour accès depuis legacy
```

### 3. Script legacy refactoré (Phase 1)

```php
<?php
// legacy/login.php - PHASE 1 : Utilise service Symfony

// Accès au container Symfony (variable $container injectée par LegacyController)
$authService = $container->get('App\Infrastructure\Legacy\Service\LegacyAuthenticationService');

$error = '';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'] ?? '';
    $password = $_POST['password'] ?? '';
    
    if (empty($username) || empty($password)) {
        $error = 'Username et password requis';
    } else {
        // CHANGEMENT : Utilisation du service au lieu de cURL
        $data = $authService->authenticate($username, $password);
        
        if ($data !== null) {
            $_SESSION['token'] = $data['token'];
            $_SESSION['user_id'] = $data['user_id'];
            $_SESSION['username'] = $username;
            
            header('Location: /dashboard.php');
            exit;
        } else {
            $error = 'Identifiants invalides';
        }
    }
}
?>
<!DOCTYPE html>
<html>
<head>
    <title>Login Legacy</title>
</head>
<body>
    <h1>Connexion</h1>
    
    <?php if ($error): ?>
        <div style="color: red;"><?= htmlspecialchars($error) ?></div>
    <?php endif; ?>
    
    <form method="POST" action="/login.php">
        <div>
            <label>Username:</label>
            <input type="text" name="username" required>
        </div>
        
        <div>
            <label>Password:</label>
            <input type="password" name="password" required>
        </div>
        
        <button type="submit">Se connecter</button>
    </form>
</body>
</html>
```

**Bénéfices Phase 1** :
- Code HTTP testable indépendamment
- Réutilisable dans d'autres scripts legacy
- Meilleure gestion des erreurs

***

## Phase 2 : Introduction du Domain Layer (DDD)

### 1. Créer les Value Objects

```php
<?php
// src/Domain/Authentication/ValueObject/Credentials.php
namespace App\Domain\Authentication\ValueObject;

readonly class Credentials
{
    public function __construct(
        public string $username,
        public string $password
    ) {
        if (empty($this->username) || empty($this->password)) {
            throw new \InvalidArgumentException('Username and password cannot be empty');
        }
    }
}
```

```php
<?php
// src/Domain/Authentication/ValueObject/AuthenticationToken.php
namespace App\Domain\Authentication\ValueObject;

readonly class AuthenticationToken
{
    public function __construct(
        public string $value,
        public \DateTimeImmutable $expiresAt
    ) {}
    
    public function isExpired(): bool
    {
        return new \DateTimeImmutable() > $this->expiresAt;
    }
    
    public function __toString(): string
    {
        return $this->value;
    }
}
```

```php
<?php
// src/Domain/Authentication/ValueObject/UserId.php
namespace App\Domain\Authentication\ValueObject;

readonly class UserId
{
    public function __construct(
        public string $value
    ) {
        if (empty($this->value)) {
            throw new \InvalidArgumentException('UserId cannot be empty');
        }
    }
    
    public static function fromString(string $value): self
    {
        return new self($value);
    }
    
    public function __toString(): string
    {
        return $this->value;
    }
}
```

### 2. Créer l'entité User (Domain)

```php
<?php
// src/Domain/Authentication/Entity/AuthenticatedUser.php
namespace App\Domain\Authentication\Entity;

use App\Domain\Authentication\ValueObject\UserId;
use App\Domain\Authentication\ValueObject\AuthenticationToken;

class AuthenticatedUser
{
    private function __construct(
        private readonly UserId $userId,
        private readonly string $username,
        private readonly AuthenticationToken $token
    ) {}
    
    public static function create(
        UserId $userId,
        string $username,
        AuthenticationToken $token
    ): self {
        if (empty($username)) {
            throw new \DomainException('Username cannot be empty');
        }
        
        return new self($userId, $username, $token);
    }
    
    public function getUserId(): UserId
    {
        return $this->userId;
    }
    
    public function getUsername(): string
    {
        return $this->username;
    }
    
    public function getToken(): AuthenticationToken
    {
        return $this->token;
    }
    
    public function isTokenValid(): bool
    {
        return !$this->token->isExpired();
    }
}
```

### 3. Créer le Use Case (Application Layer)

```php
<?php
// src/Application/Authentication/UseCase/AuthenticateUserUseCase.php
namespace App\Application\Authentication\UseCase;

use App\Domain\Authentication\Entity\AuthenticatedUser;
use App\Domain\Authentication\ValueObject\Credentials;
use App\Domain\Authentication\ValueObject\UserId;
use App\Domain\Authentication\ValueObject\AuthenticationToken;
use App\Infrastructure\Legacy\Service\LegacyAuthenticationService;

readonly class AuthenticateUserUseCase
{
    public function __construct(
        private LegacyAuthenticationService $authService
    ) {}
    
    public function execute(Credentials $credentials): ?AuthenticatedUser
    {
        $data = $this->authService->authenticate(
            $credentials->username,
            $credentials->password
        );
        
        if ($data === null) {
            return null;
        }
        
        $userId = UserId::fromString($data['user_id']);
        $token = new AuthenticationToken(
            value: $data['token'],
            expiresAt: new \DateTimeImmutable($data['expires_at'] ?? '+1 hour')
        );
        
        return AuthenticatedUser::create($userId, $credentials->username, $token);
    }
}
```

### 4. Script legacy refactoré (Phase 2)

```php
<?php
// legacy/login.php - PHASE 2 : Utilise Use Case DDD

use App\Application\Authentication\UseCase\AuthenticateUserUseCase;
use App\Domain\Authentication\ValueObject\Credentials;

$authUseCase = $container->get(AuthenticateUserUseCase::class);

$error = '';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'] ?? '';
    $password = $_POST['password'] ?? '';
    
    try {
        // CHANGEMENT : Utilisation du Use Case avec Value Objects
        $credentials = new Credentials($username, $password);
        $authenticatedUser = $authUseCase->execute($credentials);
        
        if ($authenticatedUser !== null) {
            $_SESSION['token'] = (string) $authenticatedUser->getToken();
            $_SESSION['user_id'] = (string) $authenticatedUser->getUserId();
            $_SESSION['username'] = $authenticatedUser->getUsername();
            
            header('Location: /dashboard.php');
            exit;
        } else {
            $error = 'Identifiants invalides';
        }
    } catch (\InvalidArgumentException $e) {
        $error = $e->getMessage();
    }
}
?>
<!DOCTYPE html>
<html>
<head>
    <title>Login Legacy</title>
</head>
<body>
    <h1>Connexion</h1>
    
    <?php if ($error): ?>
        <div style="color: red;"><?= htmlspecialchars($error) ?></div>
    <?php endif; ?>
    
    <form method="POST" action="/login.php">
        <div>
            <label>Username:</label>
            <input type="text" name="username" required>
        </div>
        
        <div>
            <label>Password:</label>
            <input type="password" name="password" required>
        </div>
        
        <button type="submit">Se connecter</button>
    </form>
</body>
</html>
```

**Bénéfices Phase 2** :
- Logique métier dans le Domain Layer
- Validation automatique via Value Objects
- Use Case testable unitairement
- Réutilisable dans d'autres contextes

***

## Phase 3 : Créer le Controller Symfony (Migration complète)

### 1. Controller Symfony

```php
<?php
// src/Presentation/Controller/AuthenticationController.php
namespace App\Presentation\Controller;

use App\Application\Authentication\UseCase\AuthenticateUserUseCase;
use App\Domain\Authentication\ValueObject\Credentials;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class AuthenticationController extends AbstractController
{
    public function __construct(
        private readonly AuthenticateUserUseCase $authUseCase
    ) {}
    
    #[Route('/login', name: 'app_login', methods: ['GET', 'POST'])]
    public function login(Request $request): Response
    {
        $error = null;
        
        if ($request->isMethod('POST')) {
            $username = $request->request->get('username', '');
            $password = $request->request->get('password', '');
            
            try {
                $credentials = new Credentials($username, $password);
                $authenticatedUser = $this->authUseCase->execute($credentials);
                
                if ($authenticatedUser !== null) {
                    $session = $request->getSession();
                    $session->set('token', (string) $authenticatedUser->getToken());
                    $session->set('user_id', (string) $authenticatedUser->getUserId());
                    $session->set('username', $authenticatedUser->getUsername());
                    
                    return $this->redirectToRoute('app_dashboard');
                }
                
                $error = 'Identifiants invalides';
            } catch (\InvalidArgumentException $e) {
                $error = $e->getMessage();
            }
        }
        
        return $this->render('authentication/login.html.twig', [
            'error' => $error
        ]);
    }
    
    #[Route('/logout', name: 'app_logout')]
    public function logout(Request $request): Response
    {
        $request->getSession()->invalidate();
        return $this->redirectToRoute('app_login');
    }
}
```

### 2. Template Twig

```twig
{# templates/authentication/login.html.twig #}
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Connexion</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 400px; margin: 50px auto; }
        .error { color: red; padding: 10px; background: #fee; border: 1px solid red; margin-bottom: 15px; }
        form div { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; }
        input { width: 100%; padding: 8px; box-sizing: border-box; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <h1>Connexion</h1>
    
    {% if error %}
        <div class="error">{{ error }}</div>
    {% endif %}
    
    <form method="POST" action="{{ path('app_login') }}">
        <div>
            <label for="username">Username:</label>
            <input type="text" id="username" name="username" required>
        </div>
        
        <div>
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required>
        </div>
        
        <button type="submit">Se connecter</button>
    </form>
</body>
</html>
```

### 3. Dashboard Controller

```php
<?php
// src/Presentation/Controller/DashboardController.php
namespace App\Presentation\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class DashboardController extends AbstractController
{
    #[Route('/dashboard', name: 'app_dashboard')]
    public function index(Request $request): Response
    {
        $session = $request->getSession();
        
        if (!$session->has('token')) {
            return $this->redirectToRoute('app_login');
        }
        
        return $this->render('dashboard/index.html.twig', [
            'username' => $session->get('username'),
            'user_id' => $session->get('user_id')
        ]);
    }
}
```

### 4. Template Dashboard

```twig
{# templates/dashboard/index.html.twig #}
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .logout { padding: 5px 15px; background: #dc3545; color: white; text-decoration: none; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Dashboard</h1>
        <a href="{{ path('app_logout') }}" class="logout">Déconnexion</a>
    </div>
    
    <p>Bienvenue <strong>{{ username }}</strong></p>
    <p>User ID: {{ user_id }}</p>
    
    <h2>Vos informations</h2>
    <ul>
        <li>Authentifié avec succès</li>
        <li>Token stocké en session</li>
    </ul>
</body>
</html>
```

**À ce stade** :
- `/login.php` → Legacy (via LegacyController)
- `/login` → Symfony (route native)
- `/dashboard.php` → Legacy
- `/dashboard` → Symfony
- Les deux partagent la même session

***

## Phase 4 : Repository Pattern (Clean Architecture complète)

### 1. Interface Repository (Domain)

```php
<?php
// src/Domain/Authentication/Repository/AuthenticationRepositoryInterface.php
namespace App\Domain\Authentication\Repository;

use App\Domain\Authentication\Entity\AuthenticatedUser;
use App\Domain\Authentication\ValueObject\Credentials;

interface AuthenticationRepositoryInterface
{
    /**
     * Authentifie un utilisateur avec ses credentials
     * 
     * @throws AuthenticationException Si l'authentification échoue
     */
    public function authenticate(Credentials $credentials): AuthenticatedUser;
}
```

### 2. Exception Domain

```php
<?php
// src/Domain/Authentication/Exception/AuthenticationException.php
namespace App\Domain\Authentication\Exception;

class AuthenticationException extends \DomainException
{
    public static function invalidCredentials(): self
    {
        return new self('Invalid credentials provided');
    }
    
    public static function serviceUnavailable(): self
    {
        return new self('Authentication service unavailable');
    }
}
```

### 3. Implémentation Repository (Infrastructure)

```php
<?php
// src/Infrastructure/Authentication/Repository/ErpAuthenticationRepository.php
namespace App\Infrastructure\Authentication\Repository;

use App\Domain\Authentication\Entity\AuthenticatedUser;
use App\Domain\Authentication\Repository\AuthenticationRepositoryInterface;
use App\Domain\Authentication\ValueObject\Credentials;
use App\Domain\Authentication\ValueObject\UserId;
use App\Domain\Authentication\ValueObject\AuthenticationToken;
use App\Domain\Authentication\Exception\AuthenticationException;
use App\Infrastructure\Legacy\Service\LegacyAuthenticationService;
use Psr\Log\LoggerInterface;

readonly class ErpAuthenticationRepository implements AuthenticationRepositoryInterface
{
    public function __construct(
        private LegacyAuthenticationService $authService,
        private LoggerInterface $logger
    ) {}
    
    public function authenticate(Credentials $credentials): AuthenticatedUser
    {
        try {
            $data = $this->authService->authenticate(
                $credentials->username,
                $credentials->password
            );
            
            if ($data === null) {
                $this->logger->warning('Authentication failed', [
                    'username' => $credentials->username
                ]);
                throw AuthenticationException::invalidCredentials();
            }
            
            $userId = UserId::fromString($data['user_id']);
            $token = new AuthenticationToken(
                value: $data['token'],
                expiresAt: new \DateTimeImmutable($data['expires_at'] ?? '+1 hour')
            );
            
            $this->logger->info('User authenticated successfully', [
                'user_id' => $userId->value,
                'username' => $credentials->username
            ]);
            
            return AuthenticatedUser::create($userId, $credentials->username, $token);
            
        } catch (AuthenticationException $e) {
            throw $e;
        } catch (\Exception $e) {
            $this->logger->error('Authentication service error', [
                'exception' => $e->getMessage()
            ]);
            throw AuthenticationException::serviceUnavailable();
        }
    }
}
```

### 4. Refactoring Use Case

```php
<?php
// src/Application/Authentication/UseCase/AuthenticateUserUseCase.php
namespace App\Application\Authentication\UseCase;

use App\Domain\Authentication\Entity\AuthenticatedUser;
use App\Domain\Authentication\Repository\AuthenticationRepositoryInterface;
use App\Domain\Authentication\ValueObject\Credentials;

readonly class AuthenticateUserUseCase
{
    public function __construct(
        // CHANGEMENT : Dépendance sur l'interface, pas l'implémentation
        private AuthenticationRepositoryInterface $authRepository
    ) {}
    
    public function execute(Credentials $credentials): AuthenticatedUser
    {
        return $this->authRepository->authenticate($credentials);
    }
}
```

### 5. Configuration

```yaml
# config/services.yaml (mise à jour)
services:
    # Binding de l'interface à l'implémentation
    App\Domain\Authentication\Repository\AuthenticationRepositoryInterface:
        class: App\Infrastructure\Authentication\Repository\ErpAuthenticationRepository
```

### 6. Controller mis à jour

```php
<?php
// src/Presentation/Controller/AuthenticationController.php
namespace App\Presentation\Controller;

use App\Application\Authentication\UseCase\AuthenticateUserUseCase;
use App\Domain\Authentication\ValueObject\Credentials;
use App\Domain\Authentication\Exception\AuthenticationException;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class AuthenticationController extends AbstractController
{
    public function __construct(
        private readonly AuthenticateUserUseCase $authUseCase
    ) {}
    
    #[Route('/login', name: 'app_login', methods: ['GET', 'POST'])]
    public function login(Request $request): Response
    {
        $error = null;
        
        if ($request->isMethod('POST')) {
            $username = $request->request->get('username', '');
            $password = $request->request->get('password', '');
            
            try {
                $credentials = new Credentials($username, $password);
                $authenticatedUser = $this->authUseCase->execute($credentials);
                
                $session = $request->getSession();
                $session->set('token', (string) $authenticatedUser->getToken());
                $session->set('user_id', (string) $authenticatedUser->getUserId());
                $session->set('username', $authenticatedUser->getUsername());
                
                return $this->redirectToRoute('app_dashboard');
                
            } catch (AuthenticationException $e) {
                $error = $e->getMessage();
            } catch (\InvalidArgumentException $e) {
                $error = $e->getMessage();
            }
        }
        
        return $this->render('authentication/login.html.twig', [
            'error' => $error
        ]);
    }
    
    #[Route('/logout', name: 'app_logout')]
    public function logout(Request $request): Response
    {
        $request->getSession()->invalidate();
        return $this->redirectToRoute('app_login');
    }
}
```

**Bénéfices Phase 4** :
- Inversion de dépendance complète (SOLID)
- Domain ne dépend plus de l'infrastructure
- Facilement testable avec des mocks
- Changement d'implémentation transparent

***

## Phase 5 : CQRS avec Command/Handler

### 1. Command

```php
<?php
// src/Application/Authentication/Command/AuthenticateUserCommand.php
namespace App\Application\Authentication\Command;

readonly class AuthenticateUserCommand
{
    public function __construct(
        public string $username,
        public string $password
    ) {}
}
```

### 2. Handler

```php
<?php
// src/Application/Authentication/Handler/AuthenticateUserCommandHandler.php
namespace App\Application\Authentication\Handler;

use App\Application\Authentication\Command\AuthenticateUserCommand;
use App\Domain\Authentication\Entity\AuthenticatedUser;
use App\Domain\Authentication\Repository\AuthenticationRepositoryInterface;
use App\Domain\Authentication\ValueObject\Credentials;
use Symfony\Component\Messenger\Attribute\AsMessageHandler;

#[AsMessageHandler]
readonly class AuthenticateUserCommandHandler
{
    public function __construct(
        private AuthenticationRepositoryInterface $authRepository
    ) {}
    
    public function __invoke(AuthenticateUserCommand $command): AuthenticatedUser
    {
        $credentials = new Credentials($command->username, $command->password);
        return $this->authRepository->authenticate($credentials);
    }
}
```

### 3. Controller final (ultra-léger)

```php
<?php
// src/Presentation/Controller/AuthenticationController.php
namespace App\Presentation\Controller;

use App\Application\Authentication\Command\AuthenticateUserCommand;
use App\Domain\Authentication\Exception\AuthenticationException;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Messenger\MessageBusInterface;
use Symfony\Component\Messenger\Stamp\HandledStamp;
use Symfony\Component\Routing\Attribute\Route;

class AuthenticationController extends AbstractController
{
    public function __construct(
        private readonly MessageBusInterface $commandBus
    ) {}
    
    #[Route('/login', name: 'app_login', methods: ['GET', 'POST'])]
    public function login(Request $request): Response
    {
        $error = null;
        
        if ($request->isMethod('POST')) {
            $command = new AuthenticateUserCommand(
                username: $request->request->get('username', ''),
                password: $request->request->get('password', '')
            );
            
            try {
                $envelope = $this->commandBus->dispatch($command);
                $authenticatedUser = $envelope->last(HandledStamp::class)?->getResult();
                
                if ($authenticatedUser !== null) {
                    $session = $request->getSession();
                    $session->set('token', (string) $authenticatedUser->getToken());
                    $session->set('user_id', (string) $authenticatedUser->getUserId());
                    $session->set('username', $authenticatedUser->getUsername());
                    
                    return $this->redirectToRoute('app_dashboard');
                }
                
            } catch (AuthenticationException $e) {
                $error = $e->getMessage();
            } catch (\InvalidArgumentException $e) {
                $error = $e->getMessage();
            }
        }
        
        return $this->render('authentication/login.html.twig', [
            'error' => $error
        ]);
    }
    
    #[Route('/logout', name: 'app_logout')]
    public function logout(Request $request): Response
    {
        $request->getSession()->invalidate();
        return $this->redirectToRoute('app_login');
    }
}
```

### 4. Configuration Messenger

```yaml
# config/packages/messenger.yaml
framework:
    messenger:
        default_bus: command.bus
        buses:
            command.bus:
                middleware:
                    - validation
                    - doctrine_transaction
```

### 5. Tests unitaires

```php
<?php
// tests/Unit/Application/Authentication/Handler/AuthenticateUserCommandHandlerTest.php
namespace App\Tests\Unit\Application\Authentication\Handler;

use App\Application\Authentication\Command\AuthenticateUserCommand;
use App\Application\Authentication\Handler\AuthenticateUserCommandHandler;
use App\Domain\Authentication\Entity\AuthenticatedUser;
use App\Domain\Authentication\Repository\AuthenticationRepositoryInterface;
use App\Domain\Authentication\ValueObject\Credentials;
use App\Domain\Authentication\Exception\AuthenticationException;
use PHPUnit\Framework\TestCase;

class AuthenticateUserCommandHandlerTest extends TestCase
{
    public function testSuccessfulAuthentication(): void
    {
        // Arrange
        $repository = $this->createMock(AuthenticationRepositoryInterface::class);
        $repository->expects($this->once())
            ->method('authenticate')
            ->with($this->callback(function (Credentials $creds) {
                return $creds->username === 'john' && $creds->password === 'secret';
            }))
            ->willReturn($this->createMock(AuthenticatedUser::class));
        
        $handler = new AuthenticateUserCommandHandler($repository);
        $command = new AuthenticateUserCommand('john', 'secret');
        
        // Act
        $result = $handler($command);
        
        // Assert
        $this->assertInstanceOf(AuthenticatedUser::class, $result);
    }
    
    public function testFailedAuthentication(): void
    {
        // Arrange
        $repository = $this->createMock(AuthenticationRepositoryInterface::class);
        $repository->expects($this->once())
            ->method('authenticate')
            ->willThrowException(AuthenticationException::invalidCredentials());
        
        $handler = new AuthenticateUserCommandHandler($repository);
        $command = new AuthenticateUserCommand('john', 'wrong');
        
        // Assert
        $this->expectException(AuthenticationException::class);
        
        // Act
        $handler($command);
    }
}
```

**Bénéfices Phase 5** :
- Séparation command/query (CQRS)
- Controller ultra-léger
- Middleware automatique (validation, transaction)
- Architecture prête pour event sourcing

***

## Phase 6 : Suppression du legacy

### 1. Rediriger l'ancienne route

```php
<?php
// src/Presentation/Controller/LegacyRedirectController.php
namespace App\Presentation\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class LegacyRedirectController extends AbstractController
{
    #[Route('/login.php', name: 'legacy_login_redirect')]
    public function loginRedirect(): Response
    {
        return $this->redirectToRoute('app_login', [], 301);
    }
    
    #[Route('/dashboard.php', name: 'legacy_dashboard_redirect')]
    public function dashboardRedirect(): Response
    {
        return $this->redirectToRoute('app_dashboard', [], 301);
    }
}
```

### 2. Supprimer les fichiers legacy

```bash
rm legacy/login.php
rm legacy/dashboard.php
```

### 3. Désactiver le LegacyRouteLoader

```yaml
# config/routes.yaml
app_routes:
    resource: ../src/Presentation/Controller/
    type: attribute

# legacy:  ← Commenté ou supprimé
#     resource: .
#     type: legacy
#     priority: -100
```

***
